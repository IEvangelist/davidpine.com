<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dependency-injection on IEvangelist</title>
    <link>http://davidpine.net/categories/dependency-injection/index.xml</link>
    <description>Recent content in dependency-injection on IEvangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://davidpine.net/categories/dependency-injection/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Overriding ASP.NET Core Framework-Provided Services</title>
      <link>http://davidpine.net/blog/overriding-default-di/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://davidpine.net/blog/overriding-default-di/</guid>
      <description>

&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;

&lt;p&gt;In &lt;strong&gt;.NET&lt;/strong&gt; it&amp;rsquo;s really easy to create your own interfaces and implementations. Likewise, it&amp;rsquo;s seemingly effortless to register them for dependency injection. But it is not always
obvious how to override existing implementations.  Let&amp;rsquo;s discuss various aspects of &amp;ldquo;dependency injection&amp;rdquo; and how you can override the &amp;ldquo;framework-provided services&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;As an example, let&amp;rsquo;s take a recent story on our product backlog for building a security audit of login attempts.  The story involved the capture of attempted usernames along
with their corresponding IP addresses.  This would allow system administrators to monitor for potential attackers. This would require our &lt;strong&gt;ASP.NET Core&lt;/strong&gt; application to have
custom logging implemented.&lt;/p&gt;

&lt;h2 id=&#34;logging&#34;&gt;Logging&lt;/h2&gt;

&lt;p&gt;Luckily &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ASP.NET Core Logging&lt;/code&gt;&lt;/a&gt; is simple to use and is a first-class
citizen within &lt;code&gt;ASP.NET Core&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;Logging&lt;/strong&gt; repository there is an extension method namely
&lt;a href=&#34;https://github.com/aspnet/Logging/blob/dev/src/Microsoft.Extensions.Logging/LoggingServiceCollectionExtensions.cs&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;AddLogging&lt;/code&gt;&lt;/a&gt;, here is what it
looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static IServiceCollection AddLogging(this IServiceCollection services)
{
    if (services == null)
    {
        throw new ArgumentNullException(nameof(services));
    }

    services.TryAdd(ServiceDescriptor.Singleton&amp;lt;ILoggerFactory, LoggerFactory&amp;gt;());
    services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger&amp;lt;&amp;gt;), typeof(Logger&amp;lt;&amp;gt;)));

    return services;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, it is rather simple. It adds two &lt;code&gt;ServiceDescriptor&lt;/code&gt; instances to the &lt;code&gt;IServiceCollection&lt;/code&gt;, effectively registering the given service type to the
corresponding implementation type.&lt;/p&gt;

&lt;h4 id=&#34;following-the-rabbit-down-the-hole&#34;&gt;Following the rabbit down the hole&lt;/h4&gt;

&lt;p&gt;When you create a new &lt;code&gt;ASP.NET Core&lt;/code&gt; project from &lt;strong&gt;Visual Studio&lt;/strong&gt;, all the templates follow the same pattern. They have the &lt;code&gt;Program.cs&lt;/code&gt; file with a &lt;code&gt;Main&lt;/code&gt; method that looks
very similar to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static void Main(string[] args)
{
    var host = new WebHostBuilder()
        .UseKestrel()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup&amp;lt;Startup&amp;gt;()
        .UseApplicationInsights()
        .Build();

    host.Run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;templates-program-cs&#34;&gt;Templates &lt;code&gt;Program.cs&lt;/code&gt;&lt;/h6&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/aspnet/Templates/blob/dev/src/BaseTemplates/EmptyWeb/Program.cs&#34; target=&#34;_blank&#34;&gt;Empty &amp;nbsp; &lt;i class=&#34;fa fa-external-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/aspnet/Templates/blob/dev/src/BaseTemplates/StarterWeb/Program.cs&#34; target=&#34;_blank&#34;&gt;Starter Web &amp;nbsp; &lt;i class=&#34;fa fa-external-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://github.com/aspnet/Templates/blob/dev/src/BaseTemplates/WebAPI/Program.cs&#34; target=&#34;_blank&#34;&gt;Web API &amp;nbsp; &lt;i class=&#34;fa fa-external-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;One thing that is concerning about a template like this is that the &lt;code&gt;IWebHost&lt;/code&gt; is an &lt;code&gt;IDisposable&lt;/code&gt;, so why then is this statement not wrapped in a &lt;code&gt;using&lt;/code&gt;
&lt;a href=&#34;https://github.com/IEvangelist/Templates/commit/37e78bd0dc33069901cc51924fe8a2740d1e141c&#34; target=&#34;_blank&#34;&gt;you ask&lt;/a&gt;? The answer is that the &lt;code&gt;Run&lt;/code&gt; extension method
internally wraps itself in a &lt;code&gt;using&lt;/code&gt;. If you were wondering where the &lt;code&gt;AddLogging&lt;/code&gt; occurs, it is a result of invoking the &lt;code&gt;Build&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;[ Microsoft.AspNetCore.Hosting.WebHostBuilder ] 
    public IWebHost Build() ...
        private IServiceCollection BuildCommonServices() ...
            creates services then invokes services.AddLogging()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-few-words-on-the-service-descriptor&#34;&gt;A few words on the Service Descriptor&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;ServiceDescriptor&lt;/code&gt; class is an object that &lt;em&gt;describes&lt;/em&gt; a &lt;em&gt;service&lt;/em&gt;, and this is used by dependency injection. In other words, instances of the &lt;code&gt;ServiceDescriptor&lt;/code&gt; are
descriptions of services. The &lt;code&gt;ServiceDescriptor&lt;/code&gt; class exposes several static methods that allow its instantiation.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ILoggerFactory&lt;/code&gt; interface is registered as a
&lt;a href=&#34;https://github.com/aspnet/DependencyInjection/blob/dev/src/Microsoft.Extensions.DependencyInjection.Abstractions/ServiceLifetime.cs#L14&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ServiceLifetime.Singleton&lt;/code&gt;&lt;/a&gt;
and its implementation is mapped to the &lt;code&gt;LoggerFactory&lt;/code&gt;. Likewise, the generic type &lt;code&gt;typeof(ILogger&amp;lt;&amp;gt;)&lt;/code&gt; is mapped to &lt;code&gt;typeof(Logger&amp;lt;&amp;gt;)&lt;/code&gt;. This is just one of the several key
&amp;ldquo;Framework-Provided Services&amp;rdquo; that are registered.&lt;/p&gt;

&lt;h2 id=&#34;putting-it-together&#34;&gt;Putting it together&lt;/h2&gt;

&lt;p&gt;Now we know that the framework is providing all implementations of &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt;, and resolving them as their &lt;code&gt;Logger&amp;lt;T&amp;gt;&lt;/code&gt;. We also know that we could write our own implementation of
the &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt; interface. Being that this is open-source
&lt;a href=&#34;https://github.com/aspnet/Logging/blob/dev/src/Microsoft.Extensions.Logging.Abstractions/LoggerOfT.cs&#34; target=&#34;_blank&#34;&gt;we can look to their implementation&lt;/a&gt; for inspiration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class RequestDetailLogger&amp;lt;T&amp;gt; : ILogger&amp;lt;T&amp;gt;
{
    private readonly ILogger _logger;

    public RequestDetailLogger(ILoggerFactory factory,
                               IRequestCategoryProvider requestCategoryProvider)
    {
        if (factory == null)
        {
            throw new ArgumentNullException(nameof(factory));
        }
        if (requestCategoryProvider == null)
        {
            throw new ArgumentNullException(nameof(requestCategoryProvider));
        }

        var category = requestDetailCategoryProvider.CreateCategory&amp;lt;T&amp;gt;();
        _logger = factory.CreateLogger(category);
    }

    IDisposable ILogger.BeginScope&amp;lt;TState&amp;gt;(TState state)
        =&amp;gt; _logger.BeginScope(state);

    bool ILogger.IsEnabled(LogLevel logLevel)
        =&amp;gt; _logger.IsEnabled(logLevel);

    void ILogger.Log&amp;lt;TState&amp;gt;(LogLevel logLevel, 
                             EventId eventId, 
                             TState state, 
                             Exception exception, 
                             Func&amp;lt;TState, Exception, string&amp;gt; formatter)
        =&amp;gt; _logger.Log(logLevel, eventId, state, exception, formatter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;IRequestCategoryProvider&lt;/code&gt; is defined and implemented as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;using static Microsoft.Extensions.Logging.Abstractions.Internal.TypeNameHelper;

public interface IRequestCategoryProvider
{
    string CreateCategory&amp;lt;T&amp;gt;();
}

public class RequestCategoryProvider : IRequestCategoryProvider
{
    private readonly IPrincipal _principal;
    private readonly IPAddress _ipAddress;

    public RequestCategoryProvider(IPrincipal principal,
                                   IPAddress ipAddress)
    {
        _principal = principal;
        _ipAddress = ipAddress;
    }

    public string CreateCategory&amp;lt;T&amp;gt;()
    {
        var typeDisplayName = GetTypeDisplayName(typeof(T));

        if (_principal == null || _ipAddress == null)
        {
            return typeDisplayName;
        }

        var username = _principal?.Identity?.Name;
        return $&amp;quot;User: {username}, IP: {_ipAddress} {typeDisplayName}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re curious how to get the &lt;code&gt;IPrincipal&lt;/code&gt; and &lt;code&gt;IPAddress&lt;/code&gt; into this implementation (with DI) -
&lt;a href=&#34;http://davidpine.net/blog/principal-architecture-changes/&#34; target=&#34;_blank&#34;&gt;I discussed it here&lt;/a&gt; briefly. It is pretty straight-forward. In the &lt;code&gt;Startup.ConfigureServices&lt;/code&gt;
method do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void ConfigureServices(IServiceCollection services)
{
    // ... omitted for brevity

    services.AddTransient&amp;lt;IRequestCategoryProvider, RequestCategoryProvider&amp;gt;();
    services.AddTransient&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();
    services.AddTransient&amp;lt;IPrincipal&amp;gt;(
        provider =&amp;gt; provider.GetService&amp;lt;IHttpContextAccessor&amp;gt;()
                           ?.HttpContext
                           ?.User);
    services.AddTransient&amp;lt;IPAddress&amp;gt;(
        provider =&amp;gt; provider.GetService&amp;lt;IHttpContextAccessor&amp;gt;()
                           ?.HttpContext
                           ?.Connection
                           ?.RemoteIpAddress);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we can
&lt;a href=&#34;https://github.com/aspnet/DependencyInjection/blob/dev/src/Microsoft.Extensions.DependencyInjection.Abstractions/Extensions/ServiceCollectionDescriptorExtensions.cs&#34;
   target=&#34;_blank&#34;&gt;&lt;code&gt;Replace&lt;/code&gt;&lt;/a&gt; the implementations for the &lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt; by using the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public void ConfigureServices(IServiceCollection services)
{
    // ... omitted for brevity
    services.Replace(ServiceDescriptor.Transient(typeof(ILogger&amp;lt;&amp;gt;), 
                                                 typeof(RequestDetailLogger&amp;lt;&amp;gt;)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we replace the framework-provided service as a &lt;code&gt;ServiceLifetime.Transient&lt;/code&gt;. Opposed to the default &lt;code&gt;ServiceLifetime.Singleton&lt;/code&gt;. This is more or less an extra
precaution. We know that with each request we get the &lt;code&gt;HttpContext&lt;/code&gt; from the &lt;code&gt;IHttpContextAccessor&lt;/code&gt;, and from this we have the &lt;code&gt;User&lt;/code&gt;. This is what is passed to each
&lt;code&gt;ILogger&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;This approach is valid for overriding any of the various framework-provided service implementations. It is simply a matter of knowing the correct &lt;code&gt;ServiceLifetime&lt;/code&gt; for your
specific needs. Likewise, it is a good idea to leverage the open-source libraries of the framework for inspiration. With this you can take finite control of your web-stack.&lt;/p&gt;

&lt;h1 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection&#34; target=&#34;_blank&#34;&gt;
&lt;i class=&#34;fa fa-file-text-o&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt; &lt;code&gt;ASP.NET Core - Dependency Injection&lt;/code&gt;
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rxjs on IEvangelist</title>
    <link>http://davidpine.net/categories/rxjs/index.xml</link>
    <description>Recent content in rxjs on IEvangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://davidpine.net/categories/rxjs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular2 Http with RxJS Observables</title>
      <link>http://davidpine.net/blog/angular-2-http/</link>
      <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://davidpine.net/blog/angular-2-http/</guid>
      <description>

&lt;p&gt;If you have been following the development efforts of the &lt;strong&gt;Angular2&lt;/strong&gt; project, you have witnessed certain highs and lows - but it has been a fun ride. The latest version is only a &lt;strong&gt;Release Candidate&lt;/strong&gt; and the team
is getting closer to the final release. I&amp;rsquo;m really looking forward to that! I wanted to take a moment to highlight (IMO) one of the key services of &lt;strong&gt;Angular2&lt;/strong&gt;, the &lt;code&gt;http&lt;/code&gt; service.&lt;/p&gt;

&lt;p&gt;In &lt;strong&gt;AngularJs 1&lt;/strong&gt; the &lt;code&gt;ng.IHttpService&lt;/code&gt; (aka, &lt;a href=&#34;https://docs.angularjs.org/api/ng/service/$http&#34;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt;) was based on
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;promises&lt;/a&gt; and deferrals.
In &lt;strong&gt;Angular2&lt;/strong&gt; we now rely on &lt;strong&gt;RxJS&lt;/strong&gt; and the observable pattern. In my opinion this is a huge win!
If you&amp;rsquo;re unfamiliar with &lt;em&gt;Reactive Extensions&lt;/em&gt; in general, I suggest starting &lt;a href=&#34;https://msdn.microsoft.com/en-us/data/gg577609.aspx&#34;&gt;here&lt;/a&gt;.
&lt;strong&gt;RxJS&lt;/strong&gt; is the &lt;code&gt;JavaScript&lt;/code&gt; implementation of &lt;em&gt;Reactive Extensions&lt;/em&gt;.
Let&amp;rsquo;s take a moment to compare and contrast the two, and immerse ourselves in the wonderful world of &lt;strong&gt;RxJS&lt;/strong&gt;.
Let me be clear upfront that I&amp;rsquo;m developing with &lt;code&gt;TypeScript&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;legacy-pattern&#34;&gt;Legacy Pattern&lt;/h2&gt;

&lt;p&gt;As a developer you would have to use both the &lt;code&gt;ng.IHttpService&lt;/code&gt; and the &lt;code&gt;ng.IQService&lt;/code&gt; in combination to collaborate the deferral of the
HTTP request and the promise that represented it. Consider the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module ExampleModule {
    export class ExampleService implements IExampleService {
        static $inject = [&amp;quot;$http&amp;quot;, &amp;quot;$q&amp;quot;];

        private $http: ng.IHttpService;
        private $q: ng.IQService;

        constructor($http: ng.IHttpService, 
                    $q: ng.IQService) {
            this.$http = $http;
            this.$q = $q;
        }
        
        public getFooBars(): ng.IPromise&amp;lt;FooBar[]&amp;gt; {
          var deferred = this.$q.defer&amp;lt;FooBar[]&amp;gt;();
          this.$http
              .get(&amp;quot;api/foobar&amp;quot;)
              .success((data) =&amp;gt; {
                  deferred.resolve(data);
              })
              .error((error) =&amp;gt; {
                  console.log(&amp;quot;An error occurred when requesting api/foobar.&amp;quot;, error);
                  deferred.reject(error);
              });

          return deferred.promise;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we can easily see the interaction betwixt the &lt;code&gt;ng.IHttpService ($http)&lt;/code&gt; and &lt;code&gt;ng.IQService ($q)&lt;/code&gt; services. The &lt;code&gt;$q&lt;/code&gt; variable exposes a &lt;code&gt;.defer&amp;lt;T&amp;gt;&lt;/code&gt; function that returns a deferred object.&lt;/p&gt;

&lt;h3 id=&#34;deferred-api-https-docs-angularjs-org-api-ng-service-q-the-deferred-api&#34;&gt;&lt;a href=&#34;https://docs.angularjs.org/api/ng/service/$q#the-deferred-api&#34;&gt;Deferred API&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Function&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Parameters&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(value: T)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Resolved yielding the materialized value of type &lt;code&gt;T&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;reject&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(reason: string)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Rejected with the given reason&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The deferred object instance is passed into the fluent API&amp;rsquo;s of the &lt;code&gt;$http&#39;s&lt;/code&gt; &lt;code&gt;.success&lt;/code&gt; and &lt;code&gt;.error&lt;/code&gt; functions accordingly. This pattern works great, but is very limiting and repetitive.
You end up writing a lot of boilerplate code and that isn&amp;rsquo;t very &lt;a href=&#34;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&#34;&gt;DRY&lt;/a&gt;. Let&amp;rsquo;s look at how this is approached with &lt;strong&gt;Angular2&amp;rsquo;s&lt;/strong&gt; &lt;code&gt;http&lt;/code&gt; service using the observable pattern from &lt;strong&gt;RxJS&lt;/strong&gt;!&lt;/p&gt;

&lt;h2 id=&#34;new-pattern&#34;&gt;New Pattern&lt;/h2&gt;

&lt;p&gt;To be fair, let&amp;rsquo;s implement the same functionality and public surface-area such that our example services are equivalent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {Observable} from &amp;quot;RxJS/Rx&amp;quot;;
import {Injectable} from &amp;quot;@angular/core&amp;quot;;
import {Http} from &amp;quot;@angular/http&amp;quot;;

@Injectable() export class ExampleService {
    constructor(private http: Http) { }

    getFooBars(onNext: (fooBars: FooBar[]) =&amp;gt; void) {
        this.http
            .get(&amp;quot;api/foobar&amp;quot;)
            .map(response =&amp;gt; response.json() as FooBar[])
            .subscribe(onNext,
                       error =&amp;gt; 
                       console.log(&amp;quot;An error occurred when requesting api/foobar.&amp;quot;, error));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;I am hoping that you noticed how much cleaner this code is, as well as how much more readable!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now, I know what you&amp;rsquo;re thinking&amp;hellip;these cannot possibly be the same examples, but they are in fact doing the same thing. &lt;em&gt;Dependency Injection (DI)&lt;/em&gt; in &lt;strong&gt;Angular2&lt;/strong&gt; is a lot less error prone (no more magic strings) and way easier than
it was in &lt;strong&gt;AngularJs 1&lt;/strong&gt;.
Simply do what you&amp;rsquo;d expect from any other common constructor-based DI framework, ensure that your desired &lt;code&gt;Http&lt;/code&gt; type is registered as a provider to the system. This happens by way of the &lt;code&gt;HTTP_PROVIDERS&lt;/code&gt; defined in our &lt;code&gt;boot.js&lt;/code&gt; file.
More on that in another post. With modern &lt;code&gt;TypeScript&lt;/code&gt; we can define properties and fields, and their corresponding access modifiers right from within our constructors.&lt;/p&gt;

&lt;h4 id=&#34;syntax-tip&#34;&gt;Syntax Tip&lt;/h4&gt;

&lt;p&gt;This exemplifies the comparisons in syntax between a simple constructor and the more verbose constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Simple .ctor()
constructor(private http: Http) { }

// Is equivalent to...
private http: Http;
constructor(http: Http) {
   this.http = http;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, the following is true regarding public access modifiers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Simple .ctor()
constructor(http: Http) { }

// Is equivalent to...
http: Http; // When the access modifier is omitted it&#39;s defaulted to public
constructor(http: Http) {
   this.http = http;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;comparing-the-apis&#34;&gt;Comparing the APIs&lt;/h2&gt;

&lt;p&gt;Instead of the &lt;code&gt;.success&lt;/code&gt; invocation with a corresponding &lt;code&gt;deferred.resolve&lt;/code&gt; call, we now utilize the &lt;strong&gt;RxJS&lt;/strong&gt; &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.subscribe&lt;/code&gt; operators. Let&amp;rsquo;s look at these below:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Operator&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;a href=&#34;http://reactivex.io/documentation/operators/map.html&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Transform the items emitted by an &lt;code&gt;Observable&lt;/code&gt; by applying a function to each item&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;a href=&#34;http://reactivex.io/documentation/operators/subscribe.html&#34;&gt;&lt;code&gt;subscribe&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The &lt;code&gt;Subscribe&lt;/code&gt; operator is the glue that connects an observer to an &lt;code&gt;Observable&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Mapping is easy and we can leverage some of the &lt;code&gt;TypeScript&lt;/code&gt; language features to cast the &lt;strong&gt;JSON&lt;/strong&gt; blobs returned from our services as strongly typed objects. The &lt;code&gt;map&lt;/code&gt; operator is actually
synonymous with the &lt;code&gt;select&lt;/code&gt; operator, so if you&amp;rsquo;re more familiar with that terminology you can use it interchangeably.&lt;/p&gt;

&lt;h3 id=&#34;advantages&#34;&gt;Advantages&lt;/h3&gt;

&lt;p&gt;Now that we have an understanding of how &lt;strong&gt;RxJS&lt;/strong&gt; compares to the legacy pattern, we can take advantage of all the various benefits. Imagine with me that we have a need to implement retry logic,
this would have been challenging with the legacy pattern but with the new pattern it&amp;rsquo;s as simple as saying &lt;code&gt;.retry&lt;/code&gt;. Consider the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// If this call fails, we&#39;ll try it again with the same payload two times
getFooBars(onNext: (fooBars: FooBar[]) =&amp;gt; void) {
    this.http
        .get(&amp;quot;api/foobar&amp;quot;)
        .map(response =&amp;gt; &amp;lt;FooBar[]&amp;gt;response.json())
        .retry(2)
        .subscribe(onNext,
                   error =&amp;gt; 
                   console.log(&amp;quot;An error occurred when requesting api/foobar.&amp;quot;, error));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now imagine a scenario where a user is typing and you want to provide an autocomplete, you could use &lt;code&gt;.debounce&lt;/code&gt; to pause for a brief moment prior to sending the request. Likewise,
we could apply a &lt;code&gt;.filter&lt;/code&gt; that only takes action when a certain number of characters have been entered. Finally, we might utilize &lt;code&gt;.distinctUntilChanged&lt;/code&gt; to only execute the request once
the values are actually different than they once were.&lt;/p&gt;

&lt;p&gt;You could take advantage of &lt;code&gt;.buffer&lt;/code&gt;, &lt;code&gt;.throttle&lt;/code&gt;, &lt;code&gt;.interval&lt;/code&gt;, &lt;code&gt;.window&lt;/code&gt;, &lt;code&gt;.range&lt;/code&gt;, etc&amp;hellip; The list goes on and on,
and &lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS/tree/master/src/core/linq/observable&#34; target=&#34;_blank&#34;&gt;this is the source for most of what you can take advantage&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;let-s-summarize&#34;&gt;Let&amp;rsquo;s Summarize&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Angular2&lt;/strong&gt; has a new implementation of their &lt;code&gt;http&lt;/code&gt; service that relies on &lt;strong&gt;RxJS&lt;/strong&gt;. The &lt;em&gt;API&lt;/em&gt; uses &lt;code&gt;observables&lt;/code&gt; and the &lt;code&gt;observer&lt;/code&gt; pattern to allow for a fluent experience that is rich and robust.
Getting started is straight-forward and simple. Before too long you&amp;rsquo;ll be taking advantage of the feature-full set of &lt;strong&gt;Reactive Extensions&lt;/strong&gt; and thinking in terms of data streams.
This mindset will make your life easier - trust me!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Further Reading&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/api/http/index/Http-class.html&#34; target=&#34;_blank&#34;&gt;Angular2 for TypeScript, Http&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS#why-RxJS&#34; target=&#34;_blank&#34;&gt;Why RxJS?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>